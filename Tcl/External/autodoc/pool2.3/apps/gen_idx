#!/usr/local/bin/tclsh
# -*- tcl -*-
#		Pool @mFullVersion@, as of @mDate@
#
# @comment generate index of tcl procedures suitable for autoloading by tcl
# CVS : $Id: gen_idx,v 1.7 1998/10/18 15:08:38 aku Exp $

# indexed are
# * standard tcl procedures
# * classes defined with oo-system of Sam Shen
# * tix classes
# * interp alias {} ...
#
# reads 'clsIndex' to know about class commands and to be able to
# index globally generated objects (as they are (global) commands too).
# all files *.tcl in the current directory are used
#
# 'clsIndex' is generated as byproduct by 'gen_cls', the class2tcl compiler.

#----------------------------
# copied from tixindex, then modified

proc nop {args} {}
global classes 
set    classes ""

global classlist
set    classlist {}

proc class {name} {
    global  classes classlist
    append  classes "|$name"
    lappend classlist $name
}


proc Index_Generate {dir args} {
    global errorCode errorInfo classes classlist
    set oldDir [pwd]
    cd $dir
    set dir [pwd]

    if {[file exist clsIndex] && [file readable clsIndex]} {
	source clsIndex
	if {{} != $classes} {
	    set classes "([string trimleft $classes |])"
	}
    }

    append index "# Tcl autoload index file, version 2.0\n"
    append index "# This file is generated by the \"gen_idx\" program,\n"
    append index "# *NOT* by the \"auto_mkindex\" command,\n"
    append index "# and sourced to set up indexing information for one or\n"
    append index "# more commands.  Typically each line is a command that\n"
    append index "# sets an element in the auto_index array, where the\n"
    append index "# element name is the name of a command and the value is\n"
    append index "# a script that loads the command.\n\n"

    foreach file [eval glob $args] {
	set indexOfCurrentFile ""

	set f ""
	set error [catch {
	    set f [open $file]
	    while {[gets $f line] >= 0} {
		# user defined classes ?
		if {{} != $classes} {
		    if [regexp "^$classes\[ 	\]+(\[^ 	\]*)" $line match className objectName] {
			append indexOfCurrentFile "set [list auto_index($objectName)]"
			append indexOfCurrentFile " \"source {\$dir/$file}\"\n"
		    }
		}
		if {[regexp {^interp[ 	]+alias[ 	]+\{\}[ 	]+([^ 	]*)} $line match command]} {

		    #puts "-- alias <$command> [lsearch -exact $classlist $command] ($classlist)"

		    if {
			({} != $classlist) &&
			([lsearch -exact $classlist $command] >= 0)
		    } {
			# Clear out the procedures found earlier, only the
			# classname and the autoloader entrypoint are required.

			set indexOfCurrentFile ""

			append indexOfCurrentFile "set [list auto_index(::pool::oo::class::${command}::loadClass)]"
			append indexOfCurrentFile " \"source {\$dir/$file}\"\n"
			append indexOfCurrentFile "set [list auto_index($command)]                              "
			append indexOfCurrentFile " \"source {\$dir/$file}\"\n"
		    } else {
			append indexOfCurrentFile "set [list auto_index($command)]"
			append indexOfCurrentFile " \"source {\$dir/$file}\"\n"
			#append index "set [list auto_index($command:_autoload)]"
			#append index " \"source {\$dir/$file}\"\n"
		    }
		}
		# tix classes
		if {[regexp {^tixClass[ 	]+([^ 	]*)} $line match className]} {
		    append indexOfCurrentFile "set [list auto_index($className)]"
		    append indexOfCurrentFile " \"source {\$dir/$file}\"\n"
		    append indexOfCurrentFile "set [list auto_index($className::AutoLoad)]"
		    append indexOfCurrentFile " \"source {\$dir/$file}\"\n"
		}
		if {[regexp {^tixWidgetClass[ 	]+([^ 	]*)} $line match className]} {
		    append indexOfCurrentFile "set [list auto_index($className)]"
		    append indexOfCurrentFile " \"source {\$dir/$file}\"\n"
		    append indexOfCurrentFile "set [list auto_index($className::AutoLoad)]"
		    append indexOfCurrentFile " \"source {\$dir/$file}\"\n"
		}
		# standard procedures: procedures
		if {[regexp {^proc[ 	]+([^ 	]*)} $line match procName]} {
		    # allow :_autoload! if {![string match *:* $procName]} {}
		    append indexOfCurrentFile "set [list auto_index($procName)]"
		    append indexOfCurrentFile " \"source {\$dir/$file}\"\n"
		    #{}
		}
	    }
	    close $f
	} msg] ; # {}
	if {$error} {
	    set code $errorCode
	    set info $errorInfo
	    catch {close $f}
	    cd $oldDir
	    error $msg $info $code
	} else {
	    # Add collected file index info to main index

	    append index $indexOfCurrentFile
	}
    }
    set    f [open tclIndex w]
    puts  $f $index nonewline
    close $f
    cd $oldDir
}


#----------------------------
#
if {"[lindex $argv 0]" == "-R"} {
    package require Pool_Base

    set plist ""
    ::pool::file::descendDirs d . {
	lappend plist [file join $d *.tcl]
    }

    eval Index_Generate . $plist
} else {
    Index_Generate . *.tcl
}
exit

